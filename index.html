<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="description" content="">
    <meta name="keywords" content="">
    <title></title>
</head>
<body>

    <div id="J_iAddress"></div>

<script src="https://cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
<script>

    // 1   将json数据渲染为dom结构
    // 2   给select绑定事件处理程序
    // 3   事件被触发时，执行回调，将选择的结果传递给回调
    var level = 0, init, render, createDom, getJsonFromData,
        clearAfterSelect,
        $iAddress;
    
    var cacheData = null;
    var count = 0;

    $iAddress = $('#J_iAddress');

    render = function(data){
        level++;
        var html = `<select data-level="${level}"><option value="">请选择</option>`;
            
        html += data.map(function(item, index){
            return `<option value="${ item.code }">${ item.name }</option>`;
        }).join('');

        html += `</select>`;

        return html;
    };

    // 做优化
        // 比如选了湖北省 那么再选湖北省下面的省市的话，则不需要遍历其他省了
    // 2 4 6 9
    var levelSchema = [];



    getJsonFromData = function(data, code){

        // 怎么利用这个level变量呢？ 遇到直接跳过 会不会直接跳出了递归？
        if(arguments[2]){
            console.log(arguments[2]);
        }

        count++;
        for(var i = 0; i < data.length; i++){  
            if(data[i].code === code){
                return data[i].children;
            }else{
                if(data[i].children){
                   var res = getJsonFromData(data[i].children, code);
                   if(res){
                       return res;
                   }
                }
            }
        }
    };

    // level参数是当前触发select元素的等级
    clearAfterSelect = function(_level){
        $('select').each((index, item) => {
            if($(item).attr('data-level') > _level){
                $(item).remove();
            }
        });

        level = _level;
    };
    
    init = function(data){

        // 生成省份
        $iAddress.append(render(data));

        $iAddress.on('change', 'select', function(e){
            var code = e.target.value;
            var _level = parseInt(e.target.getAttribute('data-level'));
            
            if(_level < level){
                // 只要要发生了反选择，cacheData就会被重置为省级，
                // 应该被重置为当前级别才有缓存的作用啊
                    // 1 每次缓存当前同级元素 效果： 但是后退两级重选的话，还是会检索不到数据
                    // 2 选择哪个深度的就去全局data里面根据传入的深度检索数据 效果： 但是如果如果数据很深还是要遍历很多次
                    // 3 当前选了湖北省，就把湖北省的直接子元素缓存起来，选了随州市，就把随州市的直接子元素缓存起来
                        // 再次切换省份，缓存无效，这种优化只能保证用户会一级一级选下去的情况有用
                    // 4 组合两种优化方式
                    //     1 只遍历用户选择元素的级别
                    //         正序 用户选了武汉市，就根据遍历武汉市的直接子元素
                    //         逆序 用户选了武汉市，但是接下来又选了湖南省，这样就应该去省份级别去遍历
                            // 2 递归的时候，传入一个层级，根据层级遍历，但是进入层级也是需要遍历的啊
                            // 3 每次只遍历一个省份？那市呢？ 让递归只对一个循环下的元素进行遍历 目前的递归会对每个省进行遍历
                cacheData = data;
                clearAfterSelect(_level);
            }

            if(!code || !data || !data.length){return;}


            var result = null;

            if(cacheData){
                result = cacheData = getJsonFromData(cacheData, code, _level);
            }else{
                result = cacheData = getJsonFromData(data, code, _level);
            }
            
            if(!result){return;}
            $iAddress.append(render(result));

            // console.log(count);
        });
    };

    $.getJSON('./pcas-code.json').then(function(data){
        if(data && data.length){
            init(data);
            console.log(data);
            
        }
    }, function(error){
        alert('地址数据异常');
    });

</script>
</body>
</html>
        